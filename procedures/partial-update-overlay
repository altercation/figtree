#!/bin/bash

# figtree; an Arch Linux AIF module to create conFIG TREEs from local or remote profiles
# Ethan Schoonover <es@ethanschoonover.com>
# Please see the http://ethanschoonover.com/figtree for details and usage

# this procedure updates the overlay files from a live, production system to an 
# aif profile directory

# ----------------------------------------------------------------------
# procedure specific definitions
# ----------------------------------------------------------------------

depend_procedure figtree automatic

var_MODULE_NAME=figtree
var_MODULE_DESCRIPTION="ACTION: This procedure will update the overlay files in the specified procedure(s)."
var_PROCEDURE_SUBPATH=/procedures/partial-update-overlay
var_AIF_PROCEDURE_PATH="$procedure"; [[ "$module" == "http" ]] && var_AIF_PROCEDURE_PATH="$2"
var_MODULE_PATHS=("${var_AIF_PROCEDURE_PATH%$var_PROCEDURE_SUBPATH*}")
var_OPTS_STRING="c:r:aswfnD"


# ----------------------------------------------------------------------
# PHASE WORKER CUSTOMIZATIONS
# ----------------------------------------------------------------------
phase_preparation=(preconfigure opts intro)
phase_basics=()
phase_system=(pre_overlay write_overlay post_overlay)
phase_finish=()

# Usage
# ----------------------------------------------------------------------
read -r -d '' var_ARGS_USAGE <<-EOF
========================================================================
Partial AIF procedure: figtree partial-update-overlay
------------------------------------------------------------------------
Usage examples:
------------------------------------------------------------------------

This partial procedure updates the overlay files associated with a 
figtree profile. A profile might be in:

    /usr/lib/aif/user/figtree/profiles/my-laptop

or a more scope limited profile:

    /usr/lib/aif/user/figtree/systems/make/model

The profile file itself is usually a file named "profile" in the 
directories listed above:

    /usr/lib/aif/user/figtree/profiles/my-laptop/profile

and the overlay directory is always in the same directory as the
profile file, thus:

    /usr/lib/aif/user/figtree/profiles/my-laptop/overlay

This procedure *must* be run against a local profile (the procedure can
be called remotely, in which case you should be careful to specify a
full path such as /usr/lib/aif/user/figtree/profiles/my-laptop on the
command line.

LOCAL PROCEDURE & LOCAL, RELATIVE PROFILE PATH
aif -p figtree/automatic -c profiles/my-desktop
aif -p figtree/automatic -c systems/lenovo/x220

LOCAL PROCEDURE & LOCAL, ABSOLUTE PROFILE PATH
aif -p figtree/automatic -c /tmp/aif/systems/lenovo/x220

REMOTE PROCEDURE & LOCAL PROFILE
aif -p http://github.com/user/figtree/raw/master/procedures/automatic \
    -c /usr/lib/aif/user/figtree/profiles/my-laptop

------------------------------------------------------------------------
Options:
------------------------------------------------------------------------
$(for usage_item in ${!usage_@}; do echo "${!usage_item}\n"; done)
------------------------------------------------------------------------
EOF

# ----------------------------------------------------------------------
# procedure workers
# ----------------------------------------------------------------------
OFF_worker_intro ()
{
    [[ -z "$var_PARTIAL_PROFILE" ]] && \
        die_error "You must specify a config file (-c profile/path) to use this procedure. Run this procedure again with -h for more details."
    local procname="$var_MODULE_NAME $(basename $var_AIF_PROCEDURE_PATH)"
    local default=yes
    if [[ -n "$var_WIPE_OVERLAY" ]]; then
            intro+="\n -w  Wipe overlay directory is ON. Overlay directory will be COMPLETELY REMOVED Prior to write."
            local default=no
    else
            intro+="\n(-w) Wipe overlay directory is off. Overlay directory will remain intact prior to write."
    fi
    if [[ -n "$var_FORCE_OVERWRITE" ]]; then
            intro+="\n -f  Force overwrite is ON. NO PROMPTS Will be given and all OVERWRITES WILL BE MADE."
            local default=no
    else
            intro+="\n(-f) Force overwrite is off. Prompts will be given prior to any overwrite or deletion."
    fi
    if [[ -n "$var_NO_BACKUPS" ]]
    then
            intro+="\n -b  No-backups mode is ON. NO BACKUP FILES Will be created during overwrites."
            local default=no
    else
            intro+="\n(-b) No-backup mode is off. Backups will be created during any overwrite."
    fi
    if [[ -n "$var_RECURSIVE" ]]
    then
            intro+="\n -R  Recursive mode is ON. ALL LINKED PROFILES Will be processed."
            recursive_note=" and all recursively linked profiles"
            local default=no
    else
            intro+="\n(-R) Recursive mode is off. No linked profiles will be processed."
            recursive_note=
    fi
    if [[ -n "$var_DIFFS" ]]; then
            intro+="\n -d  Diff mode is ON. Diffs will be displayed prior to file overwrite."
    else
            intro+="\n(-d) Diff mode is off. No diff information will be shown."
    fi
    inform "\nRUNNING THE $(toupper "$procname") PROCEDURE"
    inform "\nSourcing profile ${var_PARTIAL_PROFILE}${recursive_note}"
    inform "${intro}\n"
    ask_yesno "Do you want to continue?" $default || exit
}

worker_optsconfigure ()
{
    unused_opts="WIPE_OVERLAY FORCE_OVERWRITE DIFFS"
    for unused_opt in $unused_opts; do eval "unset intro_$unused_opt; unset option_$unused_opt; unset usage_$unused_opt"; done
}

worker_pre_overlay ()
{
    var_LOADED_PROFILES= # reset
    var_POST_OVERLAY=
    load_profile $var_PARTIAL_PROFILE || die_error "Failed to load profile $var_PARTIAL_PROFILE from paths $var_MODULE_PATHS"
}

worker_post_overlay ()
{
    var_LOADED_PROFILES= # reset
    var_POST_OVERLAY=1
    load_profile $var_PARTIAL_PROFILE || die_error "Failed to load profile $var_PARTIAL_PROFILE from paths $var_MODULE_PATHS"
}

write_overlay_file()
{
    local overlay_file="$1"
    to_path="${overlay_file/\/\///}"
    from_path="$var_SOURCE_DIR/${overlay_file#*\/\/}"
    if [[ -z "$var_FORCE_OVERWRITE" ]]
    then
        if [[ ! -f "$from_path" ]];      then show_warning "NO SOURCE" "Profile overlay requests non-existant source file: \"$from_path\""; return 1
        elif [[ ! -f "$to_path" ]];      then inform "No overlay file present. Copying $from_path to $to_path"
        elif [[ -n "$var_NO_BACKUPS" ]]; then ask_yesno "Overlay file present. Copy current $from_path to $to_path? NO BACKUP WILL BE CREATED." no || return 0
        else ask_yesno "Overlay file present. Copy current $from_path to $to_path? Backup will be created." yes || return 0
        fi
    fi
    if [[ -n "$var_NO_BACKUPS" ]]
    then local install_cmd='install --backup=none -C -D -v -T '
    else local install_cmd='install --backup=numbered -C -D -v -T '
    fi
    if $install_cmd "$from_path" "$to_path" &>/dev/null
    then inform "Successful update of overlay file from \"$from_path\" to \"$to_path\""; return 0
    else show_warning "CRITICAL OVERLAY FILE ERROR" "Failed to overlay file from \"$from_path\" to \"$to_path\""; return 1
    fi
}

source_and_overlay()
{
    # there is probably a clever way to get the phase
    # i could also override load_profile from figtree automatic here but
    # I'm going to use global state to make this into, effectively, two different functions that get called by load_profile
    # If this seems as dirty as it feels, then I'll have to refactor it later
    # TODO: refactor to two functions?
    # TODO: is there an easy way to pull the oldest $FUNCNAME?
    # TODO: is there a better way to handle permissions during the copy? I'll have to sort this out for userspace profiles as well
    local revert_overlay=$var_OVERLAY_PATH
    var_OVERLAY_PATH="$(dirname "$1")/overlay"
    if [[ -z $var_POST_OVERLAY ]]; then # haven't yet updated overlay
        if [[ -n "$var_WIPE_OVERLAY" && -d "$var_OVERLAY_PATH" ]]; then
                if [[ -z "$var_FORCE_OVERWRITE" ]]
                then
                        ask_yesno "Delete existing overlay directory $var_OVERLAY_PATH:" && rm -rf "$var_OVERLAY_PATH"
                else
                        rm -rf "$var_OVERLAY_PATH"
                fi
        fi
        source "$1" \
                && inform "\n${divider}\nSuccessfully loaded profile:\n${1#$var_TEMP_DIR}\n${divider}\n" \
                || die_error "Failed to process profile \"$1\"."
    elif [[ -d "$var_OVERLAY_PATH" ]]; then # we've already run through the overlay update and need to change permissions
        # the only file we *know* we have is the profile, $1
#        chmod --recursive --reference="$1" "$var_OVERLAY_PATH" \
#                && inform "Recursively updated permissions on $var_OVERLAY_PATH" \
#                || die_error "PERMISSIONS UPDATE ERROR" "Recursively updated permissions on $var_OVERLAY_PATH"
        chown --recursive --reference="$1" "$var_OVERLAY_PATH" \
                && inform "Recursively updated ownership on $var_OVERLAY_PATH" \
                || die_error "OWNERSHIP UPDATE ERROR" "Error updating ownership on $var_OVERLAY_PATH"
    fi
    var_OVERLAY_PATH=$revert_overlay
} 
