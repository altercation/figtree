#!/bin/bash

# Ethan Schoonover <es@ethanschoonover.com>

# proto-automatic
# aif procedure to install a various prototype configurations
# including hardware prototypes for specific makes/models,
# environment prototypes for common wm/de configurations
# application set prototypes (e.g. lightweight-cli apps)
# user protytpes

# also takes a user customized aif profile

# defined herein:
#
# additional custom worker(s)
# custom command line parameter handling
# revised http remote module sourcing to enable overlay, etc.
# revised profile/config source heuristic to be smart (but not too smart) about 
# where to get the specified profiles from
# addition to phases to include correct worker(s)
#
# we also define and redefine some lib functions, notably those related to 
# loading libs, files, etc. The reason for these redefined functions is that we 
# want to be able to source those file remotely, be smart (but not too smart) 
# about the path searched for those files and enable loading new types of files 
# such as the system prototype profiles. Finally we have to redefine these here 
# rather than a library script because this is the only file we can load from 
# aif remotely.

# see aif core/base procedure

depend_procedure core automatic # most of automatic fits our needs

# !!!!!TODO: it's possible we have to call some reconfig at end of phase_system due to possible changes impacting mkinitcpio
# the worker to call is configure_system. it's actually ok to call the second default function (post_configure target) several times
# though maybe better to either redefine configure_system, move it to the end, or have another post-configure worker at the end of the phase_system
phase_system+=(change_configvalues write_overlayfiles system_extras) # archproto custom workers (see below)

# use yaourt instead of pacman (see yaourt related worker/functions below)
# for repository information (see http://archlinux.fr/yaourt-en#get_it)
var_RUNTIME_REPOSITORIES=(archlinuxfr "Server = http://repo.archlinux.fr/${var_ARCH}")
var_RUNTIME_PACKAGES="augeas yaourt"

# ---------------------------------------------------------------------
# following two lines from dieter's automatic procedure, for ref
# TODO: implement setting hostname, keymap, consolefont, network settings, root 
# for a list of recognized variables, see examples/generic-install-on-sda
# ---------------------------------------------------------------------

var_ARGS_USAGE=$(cat <<EOF_ARGS_USAGE
-s <make/model>:    Specify a make/model prototype AIF system profile to install. If specified as simply "make/model" the path of the 
                    archproto module as specified in the -p parameter will be used. This allows for specifying the following:

                        aif -p archproto/automatic -s lenovo/x120e

                    and aif will automatically source the system profile from:

                        /usr/lib/aif/user/archproto/systems/lenovo/x120e/profile

                    allowing for a remote procedure source to successfully search for the system profile:

                        aif -p http://url.net/archproto/procedures/automatic -s lenovo/x120e

                    in which case the system profile will be sourced from:

                        http://url.net/archproto/systems/lenovo/x120e/profile

                    The system profile make/model can also be prefixed by a root relative full path on the local filesystem or by
                    a complete URL:

                        aif -p archproto/automatic -s /tmp/lenovo/x120e
                        aif -p http://url.net/archproto/procedures/automatic -s http://otherurl.com/mysystems/lenovo/x120e

-e
-a
-c <profile-path>:  specify a profile in one of three formats:

                        1. relative path:       systems/make/model
                        2. absolute path:       /tmp/downloads/systems/make/model
                        3. remote path:         http://github.com/archproto/profiles/my-laptop

                    All paths may refer to either an actual file or a directory containing a file named "profile". Thus:

                        profiles/my-laptop

                    can eiether be a directory with a file with the completed path: "profiles/my-laptop/profile" or a
                    profile file named "my-laptop". The use of a directory with a "profile" file is used when the profile
                    has and overlay subdirectory with overlay files for use during installation. Thus in the case of the
                    subdirectory "profiles/my-laptop", archproto/automatic will source:

                        profiles/my-laptop/profile == the profile file
                        profiles/my-laptop/overlay == files installed with the profile

                    If a relative path is specified, archproto/automatic will attempt to load it from the same module
                    location as the archproto/automatic procedure. Thus if archproto is located in:

                        /usr/lib/aif/user/archproto

                    and was specified to aif as:

                        aif -p archproto/automatic -c profiles/my-laptop

                    the procedure will look for the "profiles/my-laptop" profile in:

                        /usr/lib/aif/user/archproto/profiles/my-laptop

                    while if you have specified a remote location for the archproto/automatic procedure on the aif command line:

                        aif -p http://github.com/yourusername/archproto/procedures/automatic -c profiles/my-laptop

                    archproto/automatic will look in the same repository for the profile at:

                        http://github.com/yourusername/archproto/profiles/my-laptop

                    Note that it ok to source the archproto/automatic procedure from one remote location and the profile from another:

                        aif -p http://firsturl.net/archproto/procedures/automatic -c http://secondurl.com/archproto/profiles/my-laptop

                    Finally, it is important to note that the config profile you source can in turn source other profiles according
                    to the same rules.


EOF_ARGS_USAGE)

# process_args is called by aif master script
# and we are depending on the core/automatic profile so I'm going to keep close to it's behavior
#
# changes from core/automatic:
# - allow multiple profiles to be specified (multiple -c parameters)
# - calls load_profile to enable profile search/load logic
#
process_args ()
{
    var_AUTOMATIC_PROFILE=
    while [[ -n $1 ]]
    do
        case $1 in
            -c) [ -n "$2" ] var_AUTOMATIC_PROFILE=$2 || die_error "You must specify an aif config profile when using the -c flag." ;;
            *) usage && exit 5;;
        esac
        shift 2
    done
}

# full value of the -c profile; could be a relative, absolute or remote path
load_profile ()
{
        if profile is of type:

        absolute
                check if it exists, load it
        remote
                check if we've already loaded, if not then download the entire module...
                then turn it into an absolute path and call again
        relative
                if $module isn't http then
                        figure out where archproto has been called from and turn things back into an absolute path
                if $module is http then
                        turn it into a remote path and call load_profile again
        done!
}

worker_intro ()
{
        notify "AIF archproto automatic procedure using system profile $archproto_SYSTEM_PROFILE and additional AIF profile $var_AUTOMATIC_PROFILE\n$DISCLAIMER"
}

# from dieter's examples in unofficial subdir of aif github repo
# better to do this here rather than redefine PACMAN & PACMAN_TARGET?
worker_install_packages
{
       PACMAN_BACKUP=$PACMAN
       PACMAN_TARGET_BACKUP=$PACMAN_TARGET
       PACMAN=${PACMAN//pacman/yaourt}
       PACMAN_TARGET=${PACMAN_TARGET//pacman/yaourt}

       target_prepare_pacman core extra community
       [ -z "$TARGET_PACKAGES" ] && die_error "No packages listed for installation!"
       installpkg

       PACMAN=$PACMAN_BACKUP
       PACMAN_TARGET=$PACMAN_TARGET_BACKUP
}

worker_change_configvalues()
{
        process_config_changes $CONFIG_CHANGES
}

worker_write_overlayfiles()
{
        # This is more problematic as we have to include the correct prefix path
        # and make sure to source it properly if local/remote, etc.
        write_overlayfiles $OVERLAY_FILES
}

worker_system_extras()
{
        system_extras
}

# $1 array of packages (from official and aur) to add to TARGET_PACKAGES
# installed via standard installation functions
add_packages()
{
        [[ -n "$1" ]] && TARGET_PACKAGES+=" $1" || true
}

# $1 array of changes in augeas format to add to CONFIG_CHANGES
# later written out with write_config_changes()
add_config_changes()
{
        [[ -n "$1" ]] && CONFIG_CHANGES+=" $1"  || true
}

# $1 array of (final root relative) config files to add to OVERLAY_FILES
# later written out with write_overlay_files()
add_overlay_files()
{
        [[ -n "$1" ]] && OVERLAY_FILES+=" $1"   || true
}

write_config_changes()
{
        true
        # iterate through array of config changes
        # write changes using augeas or custom function
}

write_overlay_files()
{
        true
        # iterate over list of overlay files
        # write files using current file permissions
        # backup original file?
}

# this is a catch all function that any system profile can override
# to do anything that needs doing (custom sed commands, etc.)
# (so a profile in archproto/systems/make/model/profile can override
# this arbitrarily)
system_extras()
{
        true
}
